"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalIcon = exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _locationManager = _interopRequireDefault(require("../modules/location/locationManager"));
var _Annotation = _interopRequireDefault(require("./annotations/Annotation"));
var _CircleLayer = _interopRequireDefault(require("./CircleLayer"));
var _HeadingIndicator = _interopRequireDefault(require("./HeadingIndicator"));
var _NativeUserLocation = _interopRequireDefault(require("./NativeUserLocation"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const mapboxBlue = 'rgba(51, 181, 229, 100)';
const layerStyles = {
  normal: {
    pluse: {
      circleRadius: 15,
      circleColor: mapboxBlue,
      circleOpacity: 0.2,
      circlePitchAlignment: 'map'
    },
    background: {
      circleRadius: 9,
      circleColor: '#fff',
      circlePitchAlignment: 'map'
    },
    foreground: {
      circleRadius: 6,
      circleColor: mapboxBlue,
      circlePitchAlignment: 'map'
    }
  }
};
const normalIcon = (showsUserHeadingIndicator, heading) => [/*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationPluseCircle",
  id: "mapboxUserLocationPluseCircle",
  style: layerStyles.normal.pluse
}), /*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationWhiteCircle",
  id: "mapboxUserLocationWhiteCircle",
  style: layerStyles.normal.background
}), /*#__PURE__*/_react.default.createElement(_CircleLayer.default, {
  key: "mapboxUserLocationBlueCicle",
  id: "mapboxUserLocationBlueCicle",
  aboveLayerID: "mapboxUserLocationWhiteCircle",
  style: layerStyles.normal.foreground
}), ...(showsUserHeadingIndicator && heading !== null ? [(0, _HeadingIndicator.default)({
  heading
})] : [])];
exports.normalIcon = normalIcon;
class UserLocation extends _react.default.Component {
  static propTypes = {
    /**
     * Whether location icon is animated between updates
     */
    animated: _propTypes.default.bool,
    /**
     * Which render mode to use.
     * Can either be `normal` or `native`
     */
    renderMode: _propTypes.default.oneOf(['normal', 'native']),
    /**
     * native/android only render mode
     *
     *  - normal: just a circle
     *  - compass: triangle with heading
     *  - gps: large arrow
     *
     * @platform android
     */
    androidRenderMode: _propTypes.default.oneOf(['normal', 'compass', 'gps']),
    /**
     * Whether location icon is visible
     */
    visible: _propTypes.default.bool,
    /**
     * Callback that is triggered on location icon press
     */
    onPress: _propTypes.default.func,
    /**
     * Callback that is triggered on location update
     */
    onUpdate: _propTypes.default.func,
    /**
     * Show or hide small arrow which indicates direction the device is pointing relative to north.
     */
    showsUserHeadingIndicator: _propTypes.default.bool,
    /**
     * Request the always location permission, and listen to the location even when the app is in background
     *
     * @platform ios
     */
    requestsAlwaysUse: _propTypes.default.bool,
    /**
     * Minimum amount of movement before GPS location is updated in meters
     */
    minDisplacement: _propTypes.default.number,
    /**
     * Custom location icon of type mapbox-gl-native components
     */
    children: _propTypes.default.any
  };
  static defaultProps = {
    animated: true,
    visible: true,
    showsUserHeadingIndicator: false,
    requestsAlwaysUse: false,
    minDisplacement: 0,
    renderMode: 'normal'
  };
  static RenderMode = {
    Native: 'native',
    Normal: 'normal'
  };
  constructor(props) {
    super(props);
    this.state = {
      shouldShowUserLocation: false,
      coordinates: null,
      heading: null
    };
    this._onLocationUpdate = this._onLocationUpdate.bind(this);
  }

  // required as #setLocationManager attempts to setState
  // after component unmount
  _isMounted = null;
  locationManagerRunning = false;
  async componentDidMount() {
    this._isMounted = true;
    _locationManager.default.setMinDisplacement(this.props.minDisplacement);
    await this.setLocationManager({
      running: this.needsLocationManagerRunning()
    });
    if (this.renderMode === UserLocation.RenderMode.Native) {
      return;
    }
  }
  async componentDidUpdate(prevProps) {
    await this.setLocationManager({
      running: this.needsLocationManagerRunning()
    });
    if (this.props.minDisplacement !== prevProps.minDisplacement) {
      _locationManager.default.setMinDisplacement(this.props.minDisplacement);
    }
    if (this.props.requestsAlwaysUse !== prevProps.requestsAlwaysUse) {
      _locationManager.default.setRequestsAlwaysUse(this.props.requestsAlwaysUse);
    }
  }
  async componentWillUnmount() {
    this._isMounted = false;
    await this.setLocationManager({
      running: false
    });
  }

  /**
   * Whether to start or stop listening to the locationManager
   *
   * Notice, that listening will start automatically when
   * either `onUpdate` or `visible` are set
   *
   * @async
   * @param {Object} running - Object with key `running` and `boolean` value
   * @return {Promise<void>}
   */
  async setLocationManager(_ref) {
    let {
      running
    } = _ref;
    if (this.locationManagerRunning !== running) {
      this.locationManagerRunning = running;
      if (running) {
        _locationManager.default.addListener(this._onLocationUpdate);
        const location = await _locationManager.default.getLastKnownLocation();
        this._onLocationUpdate(location);
      } else {
        _locationManager.default.removeListener(this._onLocationUpdate);
      }
    }
  }

  /**
   *
   * If locationManager should be running
   *
   * @return {boolean}
   */
  needsLocationManagerRunning() {
    return !!this.props.onUpdate || this.props.renderMode === UserLocation.RenderMode.Normal && this.props.visible;
  }
  _onLocationUpdate(location) {
    if (!this._isMounted || !location) {
      return;
    }
    let coordinates = null;
    let heading = null;
    if (location && location.coords) {
      const {
        longitude,
        latitude
      } = location.coords;
      ({
        heading
      } = location.coords);
      coordinates = [longitude, latitude];
    }
    this.setState({
      coordinates,
      heading
    });
    if (this.props.onUpdate) {
      this.props.onUpdate(location);
    }
  }
  _renderNative() {
    const {
      androidRenderMode,
      showsUserHeadingIndicator
    } = this.props;
    let props = {
      androidRenderMode,
      iosShowsUserHeadingIndicator: showsUserHeadingIndicator
    };
    return /*#__PURE__*/_react.default.createElement(_NativeUserLocation.default, props);
  }
  render() {
    const {
      heading,
      coordinates
    } = this.state;
    const {
      children,
      visible,
      showsUserHeadingIndicator,
      onPress,
      animated
    } = this.props;
    if (!visible) {
      return null;
    }
    if (this.props.renderMode === UserLocation.RenderMode.Native) {
      return this._renderNative();
    }
    if (!coordinates) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Annotation.default, {
      animated: animated,
      id: "mapboxUserLocation",
      onPress: onPress,
      coordinates: coordinates,
      style: {
        iconRotate: heading
      }
    }, children || normalIcon(showsUserHeadingIndicator, heading));
  }
}
var _default = UserLocation;
exports.default = _default;
//# sourceMappingURL=UserLocation.js.map